# Clean Architecture

## 説明

クリーンアーキテクチャは、Robert C. Martin（通称: Uncle Bob）が2012年に提唱したアーキテクチャで、データベースやフレームワークからの独立性を確保することを目的としています。以下の図は、その象徴的なイメージです。

![clean_arc](https://github.com/user-attachments/assets/15d93d0c-3a53-46cd-83ba-f394e35cd1ed)

クリーンアーキテクチャは「特定のアーキテクチャパターン」ではなく、「アーキテクチャ設計において守るべき原則」として理解すべきです。

### 背景

クリーンアーキテクチャが発表される以前にも、**レイヤードアーキテクチャ**、**ヘキサゴナルアーキテクチャ**、**オニオンアーキテクチャ**といった手法が広く知られていましたが、それらが目指すところは同じで、「関心の分離」を実現することでした。クリーンアーキテクチャは、これらの手法を統合し、標準化したものと言えます。

上記の図に示されているように、クリーンアーキテクチャは**Enterprise Business Rules**、**Application Business Rules**、**Interface Adapters**、**Frameworks & Drivers**の4つのレイヤーに厳密に分割しなければならないというものではありません。これはあくまで一例です。提唱者であるRobert C. Martin氏も、「この図は概要に過ぎず、クリーンアーキテクチャは4層以上になることもある」と述べています。

### コアコンセプト

最も重要なのは、 **「関心の分離」** です。これを実現するために **「依存関係のルール」** や **「依存性注入」** といった概念が重要な役割を果たします。

#### 関心の分離

「関心の分離」とは、システムの異なる要素が異なる役割や責任を持つことを指します。例えば、ビジネスロジックはデータベースやUIに依存せず、独立して存在するべきです。これにより、システムの各部分が独立して変更可能になり、例えばUIを変更してもビジネスロジックに影響が出ない、あるいはデータベースを変更してもシステム全体が再構築を必要としない、といったメリットが生まれます。

#### 依存関係のルール

「依存関係のルール」においては、ソースコードの依存方向は常に内側（ビジネスルール側）に向かうべきです。内側のレイヤーは、外側（UI、データベース、フレームワーク側）のレイヤーに依存しないように設計されるべきです。

- 内側のレイヤーは外側のレイヤーについて何も知らず、特に外側のレイヤーで定義された具体的なクラスや関数、変数などを参照することは避けるべきです。
- これを実現するために、依存を逆転させる設計が重要となり、インターフェースや抽象クラスが活用されます。
- また、外側のレイヤーで使用されるデータフォーマットやフレームワークに依存しないことも大切です。これにより、外部の要素が変更された場合でも、システムのコア部分が影響を受けない構造が実現されます。

#### 依存性注入

依存性注入（Dependency Injection）は、クラスやコンポーネントが必要とする依存オブジェクトを外部から提供する手法です。これにより、クラスが自ら依存を作成したり、特定の実装に固執することを避けられます。依存性注入を用いることで、依存関係の管理が容易になり、モジュール間の結合度を低く保つことができます。

### クリーンアーキテクチャのメリット

「関心の分離」を実現することで、以下のメリットが得られます。

1. **フレームワーク独立**: アーキテクチャは、特定のフレームワークに依存せず、これらをツールとして利用できます。これにより、システムがフレームワークの制約に縛られることを防ぎます。
2. **テスト可能性**: ビジネスルールは、UI、データベース、ウェブサーバーなどの外部要素に依存せずにテストが可能です。
3. **UI独立**: UIは容易に変更可能であり、システムの他の部分に影響を与えません。例えば、Web UIをコンソールUIに変更しても、ビジネスロジックには影響がありません。
4. **データベース独立**: OracleやSQL Serverを、MongoDB、BigTable、CouchDBなどと容易に交換できます。ビジネスルールはデータベースに依存しません。
5. **外部機能独立**: ビジネスルールは外部の要素に依存せず、外側のシステムについて何も知らなくて済みます。


## 本プロジェクト

今回のプロジェクトでは、以下の4つの主要なレイヤーを採用しています。

- **Entity Layer**
- **Repository Layer**
- **Usecase Layer**
- **Interfaces Layer**

### レイヤーの詳細

#### Entity Layer

このレイヤーは、システム内の最も重要なビジネスルールやドメインを定義する役割を持ちます。DDD（ドメイン駆動設計）の観点から見ると、Entity Layerはドメインモデルやドメイン上で重要な操作を定義する場所です。これらのエンティティは、システムの他の部分から独立しており、特定のアプリケーションやインフラストラクチャに依存しない普遍的なルールを表現します。

Entity Layerは、クリーンアーキテクチャの図における**Enterprise Business Rules**に相当します。

#### Repository Layer

このレイヤーは、データベースやメール送信など、技術的な詳細に関する実装を担当します。このレイヤーは、データの永続化や外部システムとのやり取りに関する処理を抽象化し、他のレイヤーが技術的な詳細に依存しないようにします。たとえば、データベースアクセスの詳細はRepository Layerに隠蔽されており、他のレイヤーはその具体的な実装に影響を受けません。

Repository Layerは、クリーンアーキテクチャの図における**Frameworks & Drivers**に相当します。

#### Usecase Layer

このレイヤーは、システムが提供する具体的なユースケース（ビジネスロジック）を実装する役割を持ちます。このレイヤーでは、エンティティやリポジトリを利用して、システムの動作を定義します。ユースケースは、ビジネス上の特定の目的を達成するためのシナリオやプロセスを表現し、エンティティに対して操作を実行します。

Usecase Layerの変更は、エンティティには影響を与えないことが期待されます。また、このレイヤーはデータベースやUI、共通フレームワークの変更からも独立していることが求められます。このレイヤーは、これらの関心ごとから隔離されています。

Usecase Layerは、クリーンアーキテクチャの図における**Application Business Rules**に相当します。

#### Interfaces Layer

このレイヤーは、ユーザーインターフェース（UI）や外部システムとのやり取りを実装する役割を持ちます。この層では、システム外部とのインターフェースを定義し、外部からの入力を受け取って内部のユースケースやエンティティに処理を委ねます。また、

処理結果を外部に返す役割も持っています。

Interfaces Layerの変更は、他のレイヤーに影響を与えないことが期待されます。

Interfaces Layerは、クリーンアーキテクチャの図における**Interface Adapters**と**Frameworks & Drivers**に相当します。


### 依存関係

それぞれのレイヤの依存関係は以下の通りです。

<div align="center">
  <img src="https://github.com/user-attachments/assets/d8c70210-868e-4f22-91ff-4eb8793171a5" alt="clean_arc drawio (2)">
</div>

- **実線の矢印**: 直接的な依存関係を示しています。ある層が他の層やコンポーネントに対して直接依存している場合に使用します。
- **点線の矢印**: 間接的な依存関係や抽象化された依存関係を示しています。例えば、Usecase LayerはRepository Layerのインターフェースに依存しますが、具体的な実装には依存していません。


> [!NOTE]
> 依存関係の方向が正しい場合は、レイヤーをまたいでメソッドを使用することを許容する方針をとっています（interfaces -> entity）。これは、依存関係を厳密に管理しようとすると、各レイヤーで多くの変換が必要になり、コードが冗長になる可能性があるためです。

> [!NOTE]
> 本プロジェクトでは、RepositoryインターフェースをRepositoryレイヤーに実装しています。そのため、UsecaseレイヤーがRepositoryレイヤーに依存しているように見えますが、実際には具体的な実装には依存しておらず、抽象的なインターフェースにのみ依存しています。これにより、依存関係のルールは守られています。依存関係をより厳密に管理したい場合は、Repositoryインターフェースを以下のように配置すると良いでしょう。
>
> ```
> ./domain/
> ├─ model/
> └─ repository/
> ```

---

## 記述中

### 依存注入（Dependency Injection）

記述中

### 実行方法

記述中
